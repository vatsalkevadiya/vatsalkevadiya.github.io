{"ast":null,"code":"import _classCallCheck from \"C:/Users/vatsa/Downloads/React-Portfolio-master/Vatsal-Portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/vatsa/Downloads/React-Portfolio-master/Vatsal-Portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange } from \"tsparticles-engine\";\nexport var OutOutMode = /*#__PURE__*/function () {\n  function OutOutMode(container) {\n    _classCallCheck(this, OutOutMode);\n    this.container = container;\n    this.modes = [\"out\"];\n  }\n  _createClass(OutOutMode, [{\n    key: \"update\",\n    value: function update(particle, direction, delta, outMode) {\n      if (!this.modes.includes(outMode)) {\n        return;\n      }\n      var container = this.container;\n      switch (particle.outType) {\n        case \"inside\":\n          {\n            var _particle$velocity = particle.velocity,\n              vx = _particle$velocity.x,\n              vy = _particle$velocity.y;\n            var circVec = Vector.origin;\n            circVec.length = particle.moveCenter.radius;\n            circVec.angle = particle.velocity.angle + Math.PI;\n            circVec.addTo(Vector.create(particle.moveCenter));\n            var _getDistances = getDistances(particle.position, circVec),\n              dx = _getDistances.dx,\n              dy = _getDistances.dy;\n            if (vx <= 0 && dx >= 0 || vy <= 0 && dy >= 0 || vx >= 0 && dx <= 0 || vy >= 0 && dy <= 0) {\n              return;\n            }\n            particle.position.x = Math.floor(randomInRange({\n              min: 0,\n              max: container.canvas.size.width\n            }));\n            particle.position.y = Math.floor(randomInRange({\n              min: 0,\n              max: container.canvas.size.height\n            }));\n            var _getDistances2 = getDistances(particle.position, particle.moveCenter),\n              newDx = _getDistances2.dx,\n              newDy = _getDistances2.dy;\n            particle.direction = Math.atan2(-newDy, -newDx);\n            particle.velocity.angle = particle.direction;\n            break;\n          }\n        default:\n          {\n            if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n              return;\n            }\n            switch (particle.outType) {\n              case \"outside\":\n                {\n                  particle.position.x = Math.floor(randomInRange({\n                    min: -particle.moveCenter.radius,\n                    max: particle.moveCenter.radius\n                  })) + particle.moveCenter.x;\n                  particle.position.y = Math.floor(randomInRange({\n                    min: -particle.moveCenter.radius,\n                    max: particle.moveCenter.radius\n                  })) + particle.moveCenter.y;\n                  var _getDistances3 = getDistances(particle.position, particle.moveCenter),\n                    _dx = _getDistances3.dx,\n                    _dy = _getDistances3.dy;\n                  if (particle.moveCenter.radius) {\n                    particle.direction = Math.atan2(_dy, _dx);\n                    particle.velocity.angle = particle.direction;\n                  }\n                  break;\n                }\n              case \"normal\":\n                {\n                  var wrap = particle.options.move.warp,\n                    canvasSize = container.canvas.size,\n                    newPos = {\n                      bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                      left: -particle.getRadius() - particle.offset.x,\n                      right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                      top: -particle.getRadius() - particle.offset.y\n                    },\n                    sizeValue = particle.getRadius(),\n                    nextBounds = calculateBounds(particle.position, sizeValue);\n                  if (direction === \"right\" && nextBounds.left > canvasSize.width + particle.offset.x) {\n                    particle.position.x = newPos.left;\n                    particle.initialPosition.x = particle.position.x;\n                    if (!wrap) {\n                      particle.position.y = getRandom() * canvasSize.height;\n                      particle.initialPosition.y = particle.position.y;\n                    }\n                  } else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                    particle.position.x = newPos.right;\n                    particle.initialPosition.x = particle.position.x;\n                    if (!wrap) {\n                      particle.position.y = getRandom() * canvasSize.height;\n                      particle.initialPosition.y = particle.position.y;\n                    }\n                  }\n                  if (direction === \"bottom\" && nextBounds.top > canvasSize.height + particle.offset.y) {\n                    if (!wrap) {\n                      particle.position.x = getRandom() * canvasSize.width;\n                      particle.initialPosition.x = particle.position.x;\n                    }\n                    particle.position.y = newPos.top;\n                    particle.initialPosition.y = particle.position.y;\n                  } else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                    if (!wrap) {\n                      particle.position.x = getRandom() * canvasSize.width;\n                      particle.initialPosition.x = particle.position.x;\n                    }\n                    particle.position.y = newPos.bottom;\n                    particle.initialPosition.y = particle.position.y;\n                  }\n                  break;\n                }\n            }\n            break;\n          }\n      }\n    }\n  }]);\n  return OutOutMode;\n}();","map":{"version":3,"names":["Vector","calculateBounds","getDistances","getRandom","isPointInside","randomInRange","OutOutMode","container","modes","particle","direction","delta","outMode","includes","outType","velocity","vx","x","vy","y","circVec","origin","length","moveCenter","radius","angle","Math","PI","addTo","create","position","dx","dy","floor","min","max","canvas","size","width","height","newDx","newDy","atan2","getRadius","wrap","options","move","warp","canvasSize","newPos","bottom","offset","left","right","top","sizeValue","nextBounds","initialPosition"],"sources":["C:/Users/vatsa/Downloads/React-Portfolio-master/Vatsal-Portfolio/node_modules/tsparticles-updater-out-modes/esm/OutOutMode.js"],"sourcesContent":["import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"tsparticles-engine\";\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"out\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"inside\": {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= 0 && dx >= 0) || (vy <= 0 && dy >= 0) || (vx >= 0 && dx <= 0) || (vy >= 0 && dy <= 0)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case \"outside\": {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case \"normal\": {\n                        const wrap = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === \"right\" &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!wrap) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!wrap) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === \"bottom\" &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!wrap) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                            if (!wrap) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}